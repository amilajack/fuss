//!
//! Simple-Simplex - Small, lightweight simplex noise generator for Rust
//! 

#![crate_type = "lib"]
#![crate_name = "simplex"]

mod test;

extern crate rand;
use rand::{thread_rng, SeedableRng, Rng, StdRng};

// Constants

const G2 : f32 = 0.211324865;
const F2 : f32 = 0.366025403;

const GRAD3: [(i8, i8, i8); 12] = [
  (1, 1, 0), (-1, 1, 0), (1, -1, 0), (-1, -1, 0),  
  (1, 0, 1), (-1, 0, 1), (1, 0, -1), (-1, 0, -1),  
  (0, 1, 1), (0, -1, 1), (0, 1, -1), (0, -1, -1),
];

// Generate a seed
#[inline]
fn generate_seed() -> Vec<usize> {
  let mut rng = thread_rng();
  rng.gen_iter::<usize>().take(256).collect::<Vec<usize>>()
}

///
/// Hold the proper permutation tables and methods for generating 2D and 3D noise.
/// 
/// It is intended for you to get a `Simplex` through `Simplex::new()` since that
/// creates the necessary permutation tables needed to generate noise.
/// 
/// Noise generated by `Simplex` is random every time.
/// 
/// * `seed` - Seed that will be used by `Simplex` to generate it's permutation table
/// 
pub struct Simplex {

  pub seed: Vec<usize>,

  perm: Vec<u8>,

}

impl Simplex {

  ///
  /// Return a new `Simplex` with a new random permutation table
  /// 
  /// Necessary to generate the proper permutation tables (GRAD3)
  /// used by `noise_2d()` and `noise_3d`.
  /// 
  /// # Examples
  /// 
  /// ```
  /// use simplex::Simplex;
  /// 
  /// let sn = Simplex::new();
  /// ```
  /// 
  pub fn new() -> Simplex {

    return Simplex::from_seed(generate_seed());

  }

  ///
  /// Generate the permutation table
  /// 
  /// This method will overwrite the `Simplex`'s current `perm` vector
  /// with another random permutation table used by `noise_2d()` and
  /// `noise_3d`
  /// 
  pub fn generate_perms(&mut self) {
    let mut rng = StdRng::from_seed(&self.seed);
    let p : Vec<u8> = rng.gen_iter().take(256).collect::<Vec<u8>>();
    let mut perm = Vec::<u8>::new();
    for i in 0..512 {
      perm.push(p[(i & 255) as usize]);
    }
    self.perm = perm;
  }

  ///
  /// Seed the random number generator with a specific 
  /// seed
  /// 
  /// A seed is just a vector of usizes that will be passed into
  /// `StdRng::from_seed` as a slice.
  /// 
  /// # Examples
  /// 
  /// ```
  /// use simplex::Simplex;
  /// 
  /// let mut sn = Simplex::from_seed(vec![1, 2, 3]);
  /// 
  /// let mut other_sn = Simplex::from_seed(vec![1, 2, 3]);
  /// 
  /// assert_eq!(other_sn.noise_2d(1.0, 14.2), sn.noise_2d(1.0, 14.2));
  /// ```
  /// 
  pub fn from_seed(seed: Vec<usize>) -> Simplex {
    let mut sn = Simplex { 
      seed: seed,
      perm: Vec::new()
    };
    sn.generate_perms();
    return sn;
  }

  ///
  /// Find dot product of a vector in 2 dimensions
  ///
  #[inline]
  fn dot2(&self, g: (i8, i8, i8), x: f32, y: f32) -> f32 {
    g.0 as f32 * x + g.1 as f32 * y
  }

  ///
  /// Find dot product of a vector in 3 dimensions
  /// 
  #[inline]
  fn dot3(&self, g: (i8, i8, i8), x: f32, y: f32, z: f32) -> f32 {
    g.0 as f32 * x + g.1 as f32 * y + g.2 as f32 * z
  }

  ///
  /// Generate 2D simplex noise for a specific point
  /// 
  /// Returns a value in [-1, 1].
  /// 
  /// # Examples
  /// 
  /// ```
  /// use simplex::Simplex;
  /// 
  /// let sn = Simplex::new();
  /// println!("{}", sn.noise_2d(50.1912, 30.50102));
  /// 
  /// // Simplex will return the same thing for the same points
  /// assert_eq!(sn.noise_2d(1.5, -0.5), sn.noise_2d(1.5, -0.5));
  /// 
  /// let other_sn = Simplex::new();
  /// 
  /// // However each `Simplex` has it's own set of permutations, therefore
  /// // each one is different. If you want consistency, try the `from_seed()` method.
  /// assert!(sn.noise_2d(1.5, -0.5) != other_sn.noise_2d(1.5, -0.5));
  /// ```
  ///
  pub fn noise_2d(&self, xin: f32, yin: f32) -> f32 {
    let mut n0 : f32;
    let mut n1 : f32;
    let mut n2 : f32;

    let s = (xin + yin) * F2;
    let i = (xin + s).floor() as i32;
    let j = (yin + s).floor() as i32;

    let t = (i + j) as f32 * G2;
    let X0 = i as f32 -t; // Unskew the cell origin back to (x,y) space 
    let Y0 = j as f32 -t; 
    let x0 = xin-X0; // The x,y distances from the cell origin 
    let y0 = yin-Y0;
    let i1 : f32;
    let j1 : f32; // Offsets for second (middle) corner of simplex in (i,j) coords 
    if x0>y0 {
      i1 = 1.0; j1 = 0.0;
    } // lower triangle, XY order: (0,0)->(1,0)->(1,1) 
    else {
      i1=0.0; 
      j1=1.0;
    }
    let x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords 
    let y1 = y0 - j1 + G2; 
    let x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords 
    let y2 = y0 - 1.0 + 2.0 * G2; 
    let ii = (i & 255) as f32; 
    let jj = (j & 255) as f32; 
    let gi0 = self.perm[(ii as i32 + self.perm[jj as usize] as i32) as usize ] % 12; 
    let gi1 = self.perm[(ii as i32 + i1 as i32 +self.perm[(jj + j1) as usize] as i32) as usize ] % 12; 
    let gi2 = self.perm[(ii as i32 + 1 + self.perm[ (jj + 1.0) as usize] as i32) as usize] % 12; 
    
    let mut t0 = 0.5 - x0*x0-y0*y0; 
    if t0 < 0.0 {
      n0 = 0.0;
    } 
    else { 
      t0 *= t0; 
      n0 = t0 * t0 * self.dot2(GRAD3[gi0 as usize], x0, y0);  // (x,y) of GRAD3 used for 2D gradient 
    } 
    let mut t1 = 0.5 - x1*x1-y1*y1; 
    if t1 < 0. { 
      n1 = 0.0;
    } else { 
      t1 *= t1; 
      n1 = t1 * t1 * self.dot2(GRAD3[gi1 as usize], x1, y1); 
    }
    let mut t2 = 0.5 - x2*x2-y2*y2; 
    if t2 < 0.0 { 
      n2 = 0.0; 
    }
    else { 
      t2 *= t2; 
      n2 = t2 * t2 * self.dot2(GRAD3[gi2 as usize], x2, y2); 
    } 

    // Add contributions from each corner to get the final noise value. 
    // The result is scaled to return values in the interval [-1,1]. 

    return 70.0 * (n0 + n1 + n2);

  }

  ///
  /// Generate 3D simplex noise for a specific point
  /// 
  /// Returns a value in [-1, 1]. 
  /// 
  /// # Examples
  /// 
  /// ```
  /// use simplex::Simplex;
  /// 
  /// // let sn = Simplex::new();
  /// // println!("{}", sn.noise_3d(50.1912, 30.50102, -121.5));
  /// ```
  /// 
  pub fn noise_3d(&self, xin: f32, yin: f32, zin: f32) -> f32 {
    unimplemented!();
  }

}